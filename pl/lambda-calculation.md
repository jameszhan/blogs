# Lambda演算之自然数

λ演算（英语：lambda calculus，λ-calculus）是一套用于研究函数定义、函数应用和递归的形式系统。它由阿隆佐·邱奇和他的学生斯蒂芬·科尔·克莱尼在20世纪30年代引入。这种演算可以用来清晰地定义什么是一个可计算函数。

## λ演算规则
~~~
  <expression> := <name> | <function> | <application>
  <function> := λ<name>.<expression>
  <application> := <expression><expression>
~~~

### α--变换
α变换规则表达的是，被绑定变量的名称是不重要的。
α变换规则陈述的是，若v与w均为变量，E是一个lambda表达式，同时E[v/w]是指把表达式E中的所有的v的自由出现都替换成w，那么在w不是E中的一个自由出现，且如果w替换了v，w不会被E中的λ绑定的情况下，有
  λv.E == λw.E[v/w]
  例如：λx.(λx.x)x <=> λy.(λx.x)y

### β--规约
β规约规则表达的是函数作用的概念，它陈述了所有的E‘的自由出现在E[v/E']中仍然是自由的情况下，有 ((λv.E)E') == E[v/E'] 成立。

### η--变换
η变换表达的是外延性的概念，在这里外延性指的是，两个函数对于所有的参数得到的结果一致，当且仅当它们是同一个函数，η变换可以令 λx.fx和f相互交换，只要x不是f中的自由出现。


## λ演算的应用
在lambda演算系统中，一切事物都可以使用过程来描述。那么在函数式编程系统中，我们需要如何来描述一种类型呢？类型的本质在于它所定义的操作以及操作之间的关系和不变式。类型的实现关键在于满足类型规范的要求，而具体实现是可以变化的，使用者和测试用例都应该只依赖于类型规范而不依赖于具体实现。函数式的类型实现往往和类型规范是直接对应的，简单通用，但可能有性能问题，而命令式的类型实现往往会引入复杂的内部数据结构，但是其优点是高效。这两种实现并不是完全互斥的，有时候可以将二者相结合达到简单与高效的结合。

在lambda演算中有许多方式都可以定义自然数，但最常见的还是邱奇数，下面是它们的定义：

~~~
  0 := λf.λx.x
  1 := λf.λx.f x
  2 := λf.λx.f (f x)
  3 := λf.λx.f (f (f x))
~~~
以此类推。直观地说，lambda演算中的数字n就是一个把函数f作为参数并以f的n次幂为返回值的函数。换句话说，邱奇整数是一个高阶函数 -- 以单一参数函数f为参数，返回另一个单一参数的函数。

~~~
  SUCC  := λn.λf.λx.f (n f x)
  PLUS  := λm.λn.m SUCC n
  PLUS  := λm.λn.λf.λx.m f (n f x)
  MULT  := λm.λn.m (PLUS n) 0
  MULT  := λm.λn.λf.m (n f)
  PRED  := λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u)
  SUB   := λm.λn.n PRED m
  EXP   := λa.λn.n a
~~~

