---
layout: post
title:  "堆排序(C语言描述)"
author: 詹子知(James Zhan)
date:   2009-10-10 17:15:00
meta:   版权所有，转载须声明出处
category: algorithm
tags: [算法, C]
---

1991年计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd)和威廉姆斯(J．Williams)在1964年共同发明了著名的堆排序算法(Heap Sort)。
n个关键字序列Kl，K2，…，Kn称为(Heap)，当且仅当该序列满足如下性质(简称为堆性质)：

(1) Ki <= K2i且Ki <= K2i+1 或    
(2) Ki >= K2i且KI >= K2i+1 (1≤i≤ n)

若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶结点的关键字均不大于(或不小于)其左右孩子(若存在)结点的关键字。

大根堆和小根堆的根结点(亦称为堆顶)的关键字是堆里所有结点关键字中最小者的堆称为小根堆,又称最小堆. 根结点(亦称为堆顶)的关键字是堆里所有结点关键字中最大者，称为大根堆又称最大堆. 注意： ①堆中任一子树亦是堆. ②以上讨论的堆实际上是二叉堆(Binary Heap)，类似地可定义k叉堆。

堆排序(HeapSort)是一树形选择排序。堆排序的特点是：在排序过程中，将R[l..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系(参见二叉树的顺序存储结构)，在当前无序区中选择关键字最大(或最小)的记录。

直接选择排序中，为了从R[1..n]中选出关键字最小的记录，必须进行n-1次比较，然后在R[2..n]中选出关键字最小的记录，又需要做n-2次比较。事实上，后面的n-2次比较中，有许多比较可能在前面的n-1次比较中已经做过，但由于前一趟排序时未保留这些比较结果，所以后一趟排序时又重复执行了这些比较操作。

堆排序可通过树形结构保存部分比较结果，可减少比较次数。
     
实现一个数从小到大排序，既可以使用大根堆，也可以使用小根堆。
 
 
~~~c
//定义元素关系：下表从0开始。
inline int parent(int i){return (i - 1) / 2;}
inline int left(int i){ return 2 * i + 1;}
inline int right(int i){return 2 * i + 2;}
 
void adjust(int a[], int i, int n){
       int j, k;
       k = a[i];
       j = left(i);
       while(j < n){
              if(j < n - 1){
                     if(a[j + 1] > a[j]){//调整为小根堆，只需把条件换为a[j + 1] < a[j]
                        j++;
                     }                    
              }
              if(k < a[j]){
                     a[parent(j)] = a[j];
                     //找出最大的子元素，放到父节点。
                     j = left(j);
              }else{
                     break;
              }                  
       }    
       a[parent(j)] = k;    
}
 
 
//基于大根堆的排序策略。
void sort1(int a[], int n){
       int i, t;
       //建堆。
       for(i = parent(n - 1); i >= 0; i--){
              adjust(a, i, n);
       }
       for(i = n - 1; i > 0; i--){
              //无序区[0, i]，有序区[i+1, n-1];
              t = a[i];
              a[i] = a[0];
              a[0] = t;
              //交换后，无序区[0, i-1]，有序区[i, n-1]，调整无序区[0，i-1]为堆。
              adjust(a, 0, i);
       }
}
 
//基于小根堆的排序策略。
void sort2(int a[], int n){
    int i, t;
    //建堆。
    for(i = parent(n - 1); i >= 0; i--){
          adjust(a, i, n);
    }
    for(i = 1; i < n; i++){
       adjust(++a, 0, n - i);
    }
}
~~~

堆排序是不稳定排序，平均时间复杂度和最坏时间复杂度都是O(nlogn).